library(cloneRate)


calculate_leaf_info <- function(tree_data, n) {
  # Calculate the leaves
  leaves <- setdiff(tree_data$Node, tree_data$Parent)
  
  get_leaves <- function(node, tree) {
    children <- tree$Node[tree$Parent == node]
    if (length(children) == 0) {
      return(node)
    } else {
      return(unlist(lapply(children, get_leaves, tree = tree)))
    }
  }
  
  results <- data.frame(Edge = integer(), Leaves = integer(), Total_Length = numeric())
  # Calculate the lenght of branches that support k = 2,.., n-1 leaves
  for (i in 1:nrow(tree_data)) {
    node <- tree_data$Node[i]
    edge_length <- tree_data$Edge_length[i]
    
    descendant_leaves <- get_leaves(node, tree_data)
    
    num_leaves <- length(descendant_leaves)
    total_length <- edge_length
    
    results <- rbind(
      results,
      data.frame(Edge = node, Leaves = num_leaves, Total_Length = total_length)
    )
  }
  
  summed_results <- aggregate(Total_Length ~ Leaves, data = results, FUN = sum)
  
  check_leaves <- data.frame(Leaves = 1:(n - 1), Exists = FALSE, Total_Length_Positive = FALSE)
  
  for (k in check_leaves$Leaves) {
    # Check wheterh k occurs
    exists <- any(results$Leaves == k)
    positive_length <- any(results$Leaves == k & results$Total_Length > 0)
    

    check_leaves$Exists[check_leaves$Leaves == k] <- exists
    check_leaves$Total_Length_Positive[check_leaves$Leaves == k] <- positive_length
  }
  return(list(results = results, summed_results = summed_results, check_leaves = check_leaves))
}


tree_data <- data.frame(
  Node = c(102, 103, 104, 105, 106),
  Parent = c(101, 102, 102, 103, 103),
  Edge_length = c(0.14808782, 0.23143257, 0.72707157, 0.77409110, 0.43035709)
)

# Example to check whether this function is correct
print(calculate_leaf_info(tree_data, 5))



# Calculate the new estimator 
ew_durrett_adapted <- function(n, tree_data){
  sum_result <- 0
  temp = calculate_leaf_info(tree_data, n)
  for (k in 1:(n - 2)) {
    if(temp$check_leaves$Exists[k] == TRUE){
      if(k == 2){
        value <-  n / (k*(k+1)) *6/5
        
      }else if(k==3){
        value <- n / (k*(k+1)) * 2/1
      }else{
        value <-  n / (k*(k+1))
      }
      sum_result <- sum_result + value
    }
  }
  return(sum_result)
}

d = (ew_durrett_adapted(5, tree_data))
# Adaption of internalLenghts in phylofit to
# be able to calculate the lengths of branches that support
# k=2,.., n-1 leaves
internalLengths <- function(tree, alpha = 0.05) {
  # time function
  ptm <- proc.time()
  
  # If we have a list of phylo objects instead of a single phylo objects, call recursively
  if (inherits(tree, "list") & !inherits(tree, "phylo")) {
    # Call function recursively on all trees in list, then combine results into one data.frame
    return.df <- do.call(rbind, lapply(tree, internalLengths, alpha = alpha))
    return.df$cloneName_result <- names(tree)
    return(return.df)
  }
  # Get number of tips
  n <- ape::Ntip(tree)
  # Check if tree has stem
  nodes <- tree$edge[tree$edge > n]
  if (1 %in% table(nodes)) {
    hasStem <- TRUE
    stemNode <- as.numeric(names(which(table(nodes) == 1)))
  } else {
    hasStem <- FALSE
  }
  # Get the number of direct descendants from a node, identifying the nodes with > 2
  countChildren <- table(tree$edge[, 1])
  # Get list of descendants from each internal node
  descendant_df <- data.frame(
    "Node" = (n + 2):max(tree$edge), "Parent" = NA,
    "Edge_length" = NA
  )
  # Find parent and edge length preceding each internal node
  for (k in descendant_df$Node) {
    descendant_df$Edge_length[descendant_df$Node == k] <- tree$edge.length[which(tree$edge[, 2] == k)]
    descendant_df$Parent[descendant_df$Node == k] <- tree$edge[which(tree$edge[, 2] == k), 1]
  }
  # If tree has a stem, remove stem from calculation
  if (hasStem) {
    descendant_df <- descendant_df[!descendant_df$Parent == stemNode, ]
  }
  print(descendant_df)
  # The sum of edge lengths in descendant_df is equal to the total internal lengths
  intLen <- sum(descendant_df$Edge_length)
  # Calculate growth rate and confidence intervals
  growthRate <- n / intLen
  growthRate_lb <- growthRate * (1 + stats::qnorm(alpha / 2) / sqrt(n))
  growthRate_ub <- growthRate * (1 - stats::qnorm(alpha / 2) / sqrt(n))
  # Calculate total external lengths
  extLen <- sum(tree$edge.length[tree$edge[, 2] %in% c(1:n)])
  
  # Estimate clone age. If tree has stem, take tree age, otherwise estimate by adding 1/r
  if (hasStem) {
    cloneAgeEstimate <- max(ape::branching.times(tree))
  } else {
    cloneAgeEstimate <- max(ape::branching.times(tree)) + 1 / growthRate
  }
  # Get runtime (including all tests)
  runtime <- proc.time() - ptm
  
  result.df <- data.frame(
    "lowerBound" = growthRate_lb, "estimate" = growthRate,
    "upperBound" = growthRate_ub, "cloneAgeEstimate" = cloneAgeEstimate,
    "sumInternalLengths" = intLen,
    "sumExternalLengths" = extLen, extIntRatio = extLen / intLen,
    "n" = n, "alpha" = alpha, "runtime_s" = runtime[["elapsed"]],
    "method" = "lengths"
  )
  
  return(list(result.df, descendant_df))
}

# expected value of the total internal branch length according to durrett
ew_durrett <- function(n){
  sum_result <- 0
  for (k in 2:(n - 1)) {
    value <-  n / (k*(k-1))
    sum_result <- sum_result + value 
  }
  return(sum_result)
}
# Simulate the CPP and Calculate the estimators for the net growth rates
repeat_simulation <- function(num_Rep, n){
  estimator <- numeric(num_Rep)
  estimator_old <- c(num_Rep)
  estimator_mcmc <- c(num_Rep)
  estimator_new <- c(num_Rep)
  ew_durrett <- ew_durrett(n)
  for(i in 1:num_Rep){
    #print(i)
    r = 1
    a = runif(1, min = r, max = r+1)
    test <- simUltra(a,b = a - r,cloneAge = 40,n = n,nTrees = 1,precBits = 1000,addStem = FALSE,nCores = 1)
    res <- cloneRate::internalLengths(test, alpha = 0.05)
    il= res$sumInternalLengths
    test_mcmc <- birthDeathMCMC(
      test,
      maxGrowthRate = 4,
      alpha = 0.05,
      verbose = TRUE,
      nChains = 3,
      nCores = 1,
      chainLength = 2000
    )
    res_new = internalLengths(test, alpha = 0.05)
    
    ew_new <- ew_durrett_adapted(n, res_new[[2]])

    estimator[i] <-  ew_durrett/il
    estimator_old[i] <- res$estimate
    estimator_mcmc[i] <- test_mcmc$estimate
    estimator_new[i] <- ew_new/il
  }
  return(list(estimator_old, estimator, estimator_mcmc, estimator_new))
}
res_test_new_5_ev <- repeat_simulation(100, 5)
print(mean((res_test_new_5_ev[[3]]-1)^2))

res_test_new_5_05_ev <- repeat_simulation(100, 5)
print(mean((res_test_new_5_05_ev[[4]]-0.5)^2))


res_test_new <- repeat_simulation(100, 5)
res_test_new_6 <- repeat_simulation(100, 6)
res_test_new_7 <- repeat_simulation(100, 7)
res_test_new_8 <- repeat_simulation(100, 8)
res_test_new_9 <- repeat_simulation(100, 9)
res_test_new_10 <- repeat_simulation(100, 10)

res_test_new_4_1 <- repeat_simulation(100, 4)

res_test_new_1 <- repeat_simulation(100, 5)
res_test_new_6_1 <- repeat_simulation(100, 6)
res_test_new_7_1 <- repeat_simulation(100, 7)
res_test_new_8_1 <- repeat_simulation(100, 8)
res_test_new_9_1 <- repeat_simulation(100, 9)
res_test_new_10_1 <- repeat_simulation(100, 10)

res_test_new_50 <- repeat_simulation(100, 50)

print(mean((res_test_new[[4]] - 1)^2))
# 0.2855186, 0.1358415 n = 5
# 0.05259061 n=6
#  0.02954425, 0.04443502, 0.02344265 n = 10
x <- c(5,6,7,8,9,10,50)
res_old = c(mean(res_test_new[[1]]-0.5)^2, mean(res_test_new_6[[1]]-0.5)^2, mean(res_test_new_7[[1]]-0.5)^2, mean(res_test_new_8[[1]]-0.5)^2, mean(res_test_new_9[[1]]-0.5)^2, mean(res_test_new_10[[1]]-0.5)^2, mean(res_test_new_50[[1]]-0.5)^2)
res_durrett =  c(mean(res_test_new[[2]]-0.5)^2,mean(res_test_new_6[[2]]-0.5)^2,mean(res_test_new_7[[2]]-0.5)^2,mean(res_test_new_8[[2]]-0.5)^2,mean(res_test_new_9[[2]]-0.5)^2, mean(res_test_new_10[[2]]-0.5)^2, mean(res_test_new_50[[2]]-0.5)^2)
res_new = c(mean(res_test_new[[4]]-0.5)^2,  mean(res_test_new_6[[4]]-0.5)^2,  mean(res_test_new_7[[4]]-0.5)^2,  mean(res_test_new_8[[4]]-0.5)^2,  mean(res_test_new_9[[4]]-0.5)^2, mean(res_test_new_10[[4]]-0.5)^2, mean(res_test_new_50[[4]]-0.5)^2)
res_mcmc = c(mean(res_test_new[[3]]-0.5)^2,mean(res_test_new_6[[3]]-0.5)^2, mean(res_test_new_7[[3]]-0.5)^2, mean(res_test_new_8[[3]]-0.5)^2, mean(res_test_new_9[[3]]-0.5)^2, mean(res_test_new_10[[3]]-0.5)^2, mean(res_test_new_50[[3]]-0.5)^2)
plot(x, res_old, type = "b", col = "blue", pch = 19, ylim = range(c(0, 0.25)), xlim = range(c(4,50)),
     xlab = "n", ylab = "MSE")
lines(x, res_durrett, type = "b", col = "red", pch = 17)
lines(x, res_new, type = "b", col = "green", pch = 17)
lines(x, res_mcmc, type = "b", col = "black", pch = 17)

legend("topright", legend = c("Lengths", "Durrett", "New Lengths", "Phylofit"),
       col = c("blue", "red", "green", "black"), pch = c(19, 17, 17, 17), lty = 1)
# Plotten


x <- c(5,6,7,8,9,10)
res_old = c(mean((res_test_new[[1]]-0.5)^2), mean((res_test_new_6[[1]]-0.5)^2), mean((res_test_new_7[[1]]-0.5)^2), mean((res_test_new_8[[1]]-0.5)^2), mean((res_test_new_9[[1]]-0.5)^2), mean((res_test_new_10[[1]]-0.5)^2))
res_durrett =  c(mean((res_test_new[[2]]-0.5)^2),mean((res_test_new_6[[2]]-0.5)^2),mean((res_test_new_7[[2]]-0.5)^2),mean((res_test_new_8[[2]]-0.5)^2),mean((res_test_new_9[[2]]-0.5)^2), mean((res_test_new_10[[2]]-0.5)^2))
res_new = c(mean((res_test_new[[4]]-0.5)^2),  mean((res_test_new_6[[4]]-0.5)^2),  mean((res_test_new_7[[4]]-0.5)^2),  mean((res_test_new_8[[4]]-0.5)^2),  mean((res_test_new_9[[4]]-0.5)^2), mean((res_test_new_10[[4]]-0.5)^2))
res_mcmc = c(mean((res_test_new[[3]]-0.5)^2),mean((res_test_new_6[[3]]-0.5)^2), mean((res_test_new_7[[3]]-0.5)^2), mean((res_test_new_8[[3]]-0.5)^2), mean((res_test_new_9[[3]]-0.5)^2), mean((res_test_new_10[[3]]-0.5)^2))
plot(x, res_old, type = "b", col = "blue", pch = 19, ylim = range(c(0,0.5)), xlim = range(c(5,10)),
     xlab = "n", ylab = "MSE")
lines(x, res_durrett, type = "b", col = "red", pch = 17)
lines(x, res_new, type = "b", col = "green", pch = 17)
lines(x, res_mcmc, type = "b", col = "black", pch = 17)


legend("topright", legend = c("Lengths", "Durrett", "New Lengths", "Phylofit"),
       col = c("blue", "red", "green", "black"), pch = c(19, 17, 17, 17), lty = 1)

x <- c(5,6,7,8,9,10)
res_old = c(mean((res_test_new_1[[1]]-1)^2), mean((res_test_new_6_1[[1]]-1)^2), mean((res_test_new_7_1[[1]]-1)^2), mean((res_test_new_8_1[[1]]-1)^2), mean((res_test_new_9_1[[1]]-1)^2), mean((res_test_new_10_1[[1]]-1)^2))
res_durrett =  c((mean(res_test_new_1[[2]]-1)^2),mean((res_test_new_6_1[[2]]-1)^2),mean((res_test_new_7_1[[2]]-1)^2),mean((res_test_new_8_1[[2]]-1)^2),mean((res_test_new_9_1[[2]]-1)^2), mean((res_test_new_10_1[[2]]-1)^2))
res_new = c(mean((res_test_new_1[[4]]-1)^2),  mean((res_test_new_6_1[[4]]-1)^2),  mean((res_test_new_7_1[[4]]-1)^2),  mean((res_test_new_8_1[[4]]-1)^2),  mean((res_test_new_9_1[[4]]-1)^2), mean((res_test_new_10_1[[4]]-1)^2))
res_mcmc = c(mean((res_test_new_1[[3]]-1)^2),mean((res_test_new_6_1[[3]]-1)^2), mean((res_test_new_7_1[[3]]-1)^2), mean((res_test_new_8_1[[3]]-1)^2), mean((res_test_new_9_1[[3]]-1)^2), mean((res_test_new_10_1[[3]]-1)^2))
plot(x, res_old, type = "b", col = "blue", pch = 19, ylim = range(c(0., 1.7)), xlim = range(c(5,10)),
     xlab = "n", ylab = "MSE")
lines(x, res_durrett, type = "b", col = "red", pch = 17)
lines(x, res_new, type = "b", col = "green", pch = 17)
lines(x, res_mcmc, type = "b", col = "black", pch = 17)


legend("topright", legend = c("Lengths", "Durrett", "New Lengths", "Phylofit"),
       col = c("blue", "red", "green", "black"), pch = c(19, 17, 17, 17), lty = 1)
# Plotten

